//=======================================================================

//@V@:Note: This file generated by vgen V1.04 (10:25:37 22 Jun 1998).

//	gearapp.cpp:	Source for gearApp class

//=======================================================================



#include "gearapp.h"		// Header file

#include "globales.h"

#include "plugins.h"

#include <v/vnotice.h>
#include <stdio.h>
#include <unistd.h>

extern int ww,hh;

char RUNPATH[2048];         // Path de ejecución.

//=========================>>> gearApp::gearApp <<<==========================

  gearApp::gearApp(char* name, int sdi, int h, int w) : vApp(name, sdi, h, w)

  {

    // Constructor



   _gearCmdWin = 0;

  }



//=========================>>> gearApp::gearApp <<<==========================

  gearApp::~gearApp()

  {

    // Destructor

  }



//=====================>>> gearApp::NewAppWin <<<==========================

  vWindow* gearApp::NewAppWin(vWindow* win, char* name,

    int w, int h, vAppWinInfo* winInfo)

  {


    vAppWinInfo* awinfo = winInfo;

    char *appname = name;



    if (!*name)

      {

	 appname = "madIVS";		// Default name

      }

	

    UserDebug1(Build,"gearApp::NewAppWin(%s)\n",appname);



    // Create the first window using provided CmdWindow



    _gearCmdWin = (gearCmdWindow*) win;

    if (!_gearCmdWin)

      {

	_gearCmdWin = new gearCmdWindow(appname, w, h);

      }



    if (!awinfo)

	awinfo = new vAppWinInfo(appname);



    return vApp::NewAppWin(_gearCmdWin, appname, w, h, awinfo);

  }



//============================>>> gearApp::Exit <<<===========================

  void gearApp::Exit(void)

  {

    // This is called to close all windows.



    UserDebug(Build,"gearApp::Exit()\n");



    vApp::Exit();		// Default behavior

  }



//======================>>> gearApp::CloseAppWin <<<===========================

  int gearApp::CloseAppWin(vWindow* win)

  {




    // This will be called BEFORE a window has been unregistered or

    // closed.  Default behavior: unregister and close the window.



    UserDebug(Build,"gearApp::CloseAppWin()\n");



    return vApp::CloseAppWin(win);

  }



//=====================>>> gearApp::AppCommand <<<==============================

  void gearApp::AppCommand(vWindow* win, ItemVal id, ItemVal val, CmdType cType)

  {

    // Commands not processed by the window will be passed here



    UserDebug1(Build,"gearApp::AppCmd(ID: %d)\n",id);

    vApp::AppCommand(win, id, val, cType);

  }



//=========================>>> gearApp::KeyIn <<<==============================

  void gearApp::KeyIn(vWindow* win, vKey key, unsigned int shift)

  {

    // Key strokes not processed by the window will be passed here



    vApp::KeyIn(win, key, shift);

  }



//###########################################################################



  static gearApp gear_App("madIVS",1);	// The instance of the app



//============================>>> AppMain <<<==============================

int AppMain(int argc, char** argv)

  {

    // Use AppMain to create the main window



  
    /* Vamos a preparar el path de ejecución */
    
    int i;
    char auxiliar[2048];
   
#ifdef W3DWIN32
    /* En Windoze, al ejecutar la aplicación se usa el PATH absoluto */
    strcpy(RUNPATH,argv[0]);
    for (i=strlen(RUNPATH)-1;i>=0;i--)
        if ((RUNPATH[i]=='\\')) {
                RUNPATH[i+1]='\0';
                break;
        }

#endif
#ifdef LINUX
    /* En linux es habitual ejecutarlo de las dos maneras */

    if (argv[0][0]=='/') {  //Path absoluto
    printf("Path absoluto\n");
    strcpy(RUNPATH,argv[0]);
    for (i=strlen(RUNPATH)-1;i>=0;i--)
        if ((RUNPATH[i]=='/')) {
                RUNPATH[i+1]='\0';
                break;
        }
    }

    else {  //Path relativo
      printf("Path relativo\n");
      strcpy(RUNPATH,argv[0]);
      for (i=strlen(RUNPATH)-1;i>=0;i--)
        if ((RUNPATH[i]=='/')) {
          RUNPATH[i+1]='\0';
          break;
        }

      getcwd(auxiliar,2046);
      chdir(RUNPATH);      // Cambiamos al directorio del programa
      getcwd(RUNPATH,2046);// Almacenamos ese directorio
      strcat(RUNPATH,"/"); // Añadimos la barra
      chdir(auxiliar);
    }
#endif

    printf("RUNPATH : %s\n", RUNPATH);
    
    (void) theApp->NewAppWin(0, "madIVS", ww,hh);
    vNoticeDialog note(theApp);
//    note.Notice(RUNPATH);
    if (argc>1) {
            char msg[1024];
            char *extension;
            int plugin_elegido=0;
            /* Hay que decidir con que plugin cargarlo */
            extension=&argv[1][strlen(argv[1])-3];
            printf("Extension: %s\n",extension);
            for (int i=0;i<numero_plugins;i++)
              if (strstr(plugins[i].extension,extension)==NULL)
                continue;
              else
                  plugin_elegido=i;



            if (importar_modelo(plugin_elegido,argv[1])!=1) {
                        sprintf(msg,"No pude importar %s",argv[1]);
                        note.Notice(msg);
                        modelo_cargado=0;
            }
            else
                        modelo_cargado=1;
    }

    return 0;

  }

