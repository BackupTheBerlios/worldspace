//=======================================================================
//@V@:Note: This file generated by vgen V1.04 (10:25:37 22 Jun 1998).
//      gearcnv.cpp:    Source for gearOGLCanvasPane class
//=======================================================================

#include "gearcnv.h"

#include <stdlib.h>
#include <math.h>
#ifndef _WIN32
#include <unistd.h>
#endif /*  */
/* Some <math.h> files do not define M_PI... */
#ifndef M_PI
#define M_PI 3.14159265
#endif /*  */
#include <sys/types.h>
#include <stdio.h>
/* For portability... */
#undef fcos
#undef fsin
#undef fsqrt
#define fcos  cos
#define fsin  sin
#define fsqrt sqrt
#include "globales.h"
modelo *model;
static double d_near = 1.0;
static double d_far = 2000;
static int poo = 0;

/* Flags*/
char textura_cargada = 0;
char modelo_cargado = 0;
char modo_dibujo = 0;
char luces = 1;
GLuint textura;
char raton_pulsado = 0;
int rX = 0;
int rY = 0;
int ww = 512;
int hh = 384;

  /* Un poco de luz */
GLfloat LightAmbient[] = {
  0.0f, 0.0f, 0.0f, 1.0f
};

GLfloat LightDiffuse1[] = {
  1.0f, 1.0f, 1.0f, 1.0f
};

GLfloat LightPosition1[] = {
  0.0f, 1.0f, 1.0f, 0.0f
};

GLfloat ambRefl[] = {
  0.2, 0.2, 0.2, 1.0
};				// default
GLfloat diffRefl[] = { 0.8, 0.8, 0.8, 1.0 };	// default
GLfloat specRefl[] = { 1.0, 1.0, 1.0, 1.0 };	// default

double matriz_proyeccion_A[4][4];
double matriz_modelview[4][4];

float quaternion[4];

float zoom = -1.0f;
typedef struct
{
  float rad, wid;
} Profile;

int circle_subdiv;

int render_mad(modelo * mad, int mode)
{
    uint j;

    	for (j = 0; j < mad->n_caras; j++) {

        glBegin(mode);
        glTexCoord2f(mad->triangulos[j].vertices[0].u,
                     mad->triangulos[j].vertices[0].v);
        glNormal3f(mad->triangulos[j].vertices[0].Nx,
                   mad->triangulos[j].vertices[0].Ny,
                   mad->triangulos[j].vertices[0].Nz);
        glVertex3f(mad->triangulos[j].vertices[0].x ,
                   mad->triangulos[j].vertices[0].y ,
                   mad->triangulos[j].vertices[0].z );
        glTexCoord2f(mad->triangulos[j].vertices[1].u,
                     mad->triangulos[j].vertices[1].v);
        glNormal3f(mad->triangulos[j].vertices[1].Nx,
                   mad->triangulos[j].vertices[1].Ny,
                   mad->triangulos[j].vertices[1].Nz);
        glVertex3f(mad->triangulos[j].vertices[1].x ,
                   mad->triangulos[j].vertices[1].y ,
                   mad->triangulos[j].vertices[1].z );
        glTexCoord2f(mad->triangulos[j].vertices[2].u,
                     mad->triangulos[j].vertices[2].v);
        glNormal3f(mad->triangulos[j].vertices[2].Nx,
                   mad->triangulos[j].vertices[2].Ny,
                   mad->triangulos[j].vertices[2].Nz);
        glVertex3f(mad->triangulos[j].vertices[2].x ,
                   mad->triangulos[j].vertices[2].y ,
                   mad->triangulos[j].vertices[2].z );
        glEnd();
    }
 
}

void
display (void)
{
  int j;

  glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  if (modelo_cargado == 0)
    {
      return;
    }
  glMatrixMode (GL_PROJECTION);
  glLoadMatrixd (&matriz_proyeccion_A[0][0]);
  glMatrixMode (GL_MODELVIEW);
  glLoadMatrixd (&matriz_modelview[0][0]);
  glDisable (GL_LIGHTING);
  glDisable (GL_TEXTURE_2D);
  glBegin (GL_LINES);
  glColor3f (1.0f, 0.0f, 0.0f);
  glVertex3f (0.0f, 0.0f, 0.0f);
  glVertex3f (0.1f, 0.0f, 0.0f);
  glColor3f (0.0f, 1.0f, 0.0f);
  glVertex3f (0.0f, 0.0f, 0.0f);
  glVertex3f (0.0f, 0.1f, 0.0f);
  glColor3f (0.0f, 0.0f, 1.0f);
  glVertex3f (0.0f, 0.0f, 0.0f);
  glVertex3f (0.0f, 0.0f, 10.1f);
  glEnd ();
  glColor3f (1.0f, 1.0f, 1.0f);
  glMaterialfv (GL_FRONT, GL_SPECULAR, specRefl);
  glMaterialfv (GL_FRONT, GL_DIFFUSE, diffRefl);
  glMaterialfv (GL_FRONT, GL_AMBIENT, ambRefl);
  glMaterialfv (GL_FRONT, GL_EMISSION, ambRefl);
    
  if (luces == 1)
    glEnable (GL_LIGHTING);
  if ((modo_dibujo == 3) && (textura_cargada == 1))
    glEnable (GL_TEXTURE_2D);

  else
    glDisable (GL_TEXTURE_2D);
  if ((modo_dibujo == 3) && (textura_cargada == 1))
    glBindTexture (GL_TEXTURE_2D, textura);
  
      if (modo_dibujo == 0)
	{
	  glLineWidth (6);
	  render_mad(model,GL_TRIANGLES);
	}

      else if (modo_dibujo == 1)
	{
	  glLineWidth (1);
	  render_mad(model,GL_LINE_LOOP);
	}

      else if (modo_dibujo == 3)
	{
	  glLineWidth (1);
	  render_mad(model,GL_TRIANGLES);
	}

     
}
void
myReshape (int w, int h)
{
  ww = w;
  hh = h;
  glViewport (0, 0, w, h);
  glMatrixMode (GL_PROJECTION);
  glLoadIdentity ();
  gluPerspective (45.0f, (GLfloat) w / h, 0.01f, 100.0f);
  glGetDoublev (GL_PROJECTION_MATRIX, &matriz_proyeccion_A[0][0]);
  glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  } 

void
myinit (void)
{
  glMatrixMode (GL_PROJECTION);
  glLoadIdentity ();
  gluPerspective (45.0f, (GLfloat) 1.3, 0.01f, 100.0f);
  glGetDoublev (GL_PROJECTION_MATRIX, &matriz_proyeccion_A[0][0]);
  glLoadMatrixd (&matriz_proyeccion_A[0][0]);
  glMatrixMode (GL_MODELVIEW);
  glLoadIdentity ();
  glTranslatef (0.0f, 0.0f, zoom);
  glGetDoublev (GL_MODELVIEW_MATRIX, &matriz_modelview[0][0]);

  /* Ahora establecemos el color de fondo por defecto. Está en formato RGBA y lo ponemos a negro */
  glClearColor (0.0f, 0.0f, 0.0f, 0.0f);

  /* Estas 3 líneas habilitan del Buffer de profundidad */
  glClearDepth (1.0f);
  glEnable (GL_DEPTH_TEST);
  glDepthFunc (GL_LEQUAL);
  glEnable (GL_BLEND);
  glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
  glEnable (GL_ALPHA_TEST);

  /* Esta función sirve para optimizar el renderizado, y se utiliza para muchas cosas. En este caso es para
     hacer un buen cálculo de la perspectiva perdiendo un poco de rendimiento */
  glHint (GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);

  /* Cargamos la textura */
  /*glEnable(GL_TEXTURE_2D);
     glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
     glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE); */
  glShadeModel (GL_SMOOTH);	/* SMOOTH SHADING */
  glCullFace (GL_BACK);
  glEnable (GL_CULL_FACE);
  glLineWidth (6);
  glLightfv (GL_LIGHT1, GL_AMBIENT, LightAmbient);
  glLightfv (GL_LIGHT1, GL_DIFFUSE, LightDiffuse1);
  glLightfv (GL_LIGHT1, GL_POSITION, LightPosition1);
  glEnable (GL_LIGHTING);
  glEnable (GL_LIGHT1);
  glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  //display ();
}

//===================>>> gearOGLCanvasPane::gearOGLCanvasPane <<<====================
gearOGLCanvasPane::gearOGLCanvasPane ()
{
  myinit ();
  initDone = 0;
}

//===================>>> gearOGLCanvasPane::~gearOGLCanvasPane <<<====================
gearOGLCanvasPane::~gearOGLCanvasPane ()
{
}

//======================>>> gearOGLCanvasPane::TimerAnimate <<<========================
void
gearOGLCanvasPane::TimerAnimate (void)
{

  // **** Called by CmdWindow AuxTimer for animation.
  vglMakeCurrent ();		// Typically done here
  display ();
  vglFlush ();			// After you draw, typically flush

}

//======================>>> gearOGLCanvasPane::graphicsInit <<<========================
void
gearOGLCanvasPane::graphicsInit (void)
{
  vBaseGLCanvasPane::graphicsInit ();	// Always call the superclass first!

  // **** Your OpenGL initialization code goes here!

  myinit ();
  initDone = 1;
}

//======================>>> gearOGLCanvasPane::HPage <<<========================
void
gearOGLCanvasPane::HPage (int shown, int top)
{
  vBaseGLCanvasPane::HPage (shown, top);
}

//======================>>> gearOGLCanvasPane::VPage <<<========================
void
gearOGLCanvasPane::VPage (int shown, int top)
{
  vBaseGLCanvasPane::VPage (shown, top);
}

//=======================>>> gearOGLCanvasPane::HScroll <<<======================
void
gearOGLCanvasPane::HScroll (int step)
{
  vBaseGLCanvasPane::HScroll (step);
}

//======================>>> gearOGLCanvasPane::VScroll <<<======================
void
gearOGLCanvasPane::VScroll (int step)
{
  vBaseGLCanvasPane::VScroll (step);
}

//======================>>> gearOGLCanvasPane::MouseDown <<<======================
void
gearOGLCanvasPane::MouseDown (int X, int Y, int button)
{
  vBaseGLCanvasPane::MouseUp (X, Y, button);
  raton_pulsado = 1;
  rX = X;
  rY = Y;

  //printf("Click!\n");
}

//========================>>> gearOGLCanvasPane::MouseUp <<<======================
void
gearOGLCanvasPane::MouseUp (int X, int Y, int button)
{
  vBaseGLCanvasPane::MouseDown (X, Y, button);
  raton_pulsado = 0;

  //printf("Clock!!\n");
}

//======================>>> gearCanvasPane::MouseMove <<<======================
void
gearOGLCanvasPane::MouseMove (int x, int y, int button)
{
  float spin_quat[4];
  vBaseGLCanvasPane::MouseMove (x, y, button);
  if (button == 1)
    {
      glMatrixMode (GL_MODELVIEW);
      glLoadMatrixd (&matriz_modelview[0][0]);
      glRotatef (x - rX, matriz_modelview[0][1], matriz_modelview[1][1],
		 matriz_modelview[2][1]);
      glGetDoublev (GL_MODELVIEW_MATRIX, &matriz_modelview[0][0]);
      glLoadMatrixd (&matriz_modelview[0][0]);
      glRotatef (y - rY, matriz_modelview[0][0], matriz_modelview[1][0],
		 matriz_modelview[2][0]);
      glGetDoublev (GL_MODELVIEW_MATRIX, &matriz_modelview[0][0]);
      rX = x;
      rY = y;
    }
  if (button == 3)
    {
      if (y > rY)
	zoom += 0.02f;

      else
	zoom -= 0.02f;
      rX = x;
      rY = y;
      matriz_modelview[3][2] = (double) zoom;
    }
}

//=========================>>> gearOGLCanvasPane::Redraw <<<======================
void
gearOGLCanvasPane::Redraw (int x, int y, int w, int h)
{
  static int inRedraw = 0;
  if (inRedraw || !initDone)	// Don't draw until initialized
    return;
  inRedraw = 1;			// Don't allow recursive redraws.

  vglMakeCurrent ();		// Typically done here

  // *** Your drawing code typically goes here. You may
  // insert it here, or just call a drawing routine.

  display ();
  vglFlush ();			// After you draw, typically flush

  inRedraw = 0;			// Out of Redraw

}

//======================>>> gearOGLCanvasPane::Resize <<<======================
void
gearOGLCanvasPane::Resize (int w, int h)
{
  vBaseGLCanvasPane::Resize (w, h);
  myReshape (w, h);
  vglMakeCurrent ();
  display();
  vglFlush ();	
}
