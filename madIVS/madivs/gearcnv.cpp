//=======================================================================
//@V@:Note: This file generated by vgen V1.04 (10:25:37 22 Jun 1998).
//	gearcnv.cpp:	Source for gearOGLCanvasPane class
//=======================================================================

#include "gearcnv.h"

#include <stdlib.h>
#include <math.h>
#ifndef _WIN32
#include <unistd.h>
#endif
/* Some <math.h> files do not define M_PI... */
#ifndef M_PI
#define M_PI 3.14159265
#endif
#include <sys/types.h>
#include <stdio.h>

/* For portability... */
#undef fcos
#undef fsin
#undef fsqrt
#define fcos  cos
#define fsin  sin
#define fsqrt sqrt

#include "globales.h"

modelo *model;

static double d_near = 1.0;
static double d_far = 2000;
static int poo = 0;

/* Flags*/

char textura_cargada=0;
char modelo_cargado=0;
char modo_dibujo=0;

char raton_pulsado=0;
int rX=0;
int rY=0;

int ww=300;
int hh=300;


    /* Un poco de luz*/

GLfloat LightAmbient[] = { 1.0f, 1.0f, 1.0f, 1.0f };
GLfloat LightDiffuse1[] = { 1.0f, 1.0f, 1.0f, 1.0f };
GLfloat LightPosition1[] = { 0.0f, 5.0f, 0.0f, 1.0f };

double matriz_proyeccion_A[4][4];
double matriz_modelview[4][4];
float quaternion[4];
float zoom=-1.0f;
GLuint textura;


typedef struct {
  float rad, wid;
} Profile;


int circle_subdiv;



void display(void)
{
  int j;
  float view_x1, view_x2, view_x3, view_y1, view_y2, view_y3, view_z1,
        view_z2, view_z3;

  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

  if (modelo_cargado==0) {
        return;
  }



    glMatrixMode(GL_PROJECTION);
    glLoadMatrixd(&matriz_proyeccion_A[0][0]);

    glMatrixMode(GL_MODELVIEW);
    glLoadMatrixd(&matriz_modelview[0][0]);
  	glDisable(GL_LIGHTING);
		glDisable(GL_TEXTURE_2D);

		glBegin(GL_LINES);
					glColor3f(1.0f,0.0f,0.0f);
			 glVertex3f(0.0f,0.0f,0.0f);
			 glVertex3f(0.1f,0.0f,0.0f);
	
		glColor3f(0.0f,1.0f,0.0f);

			 glVertex3f(0.0f,0.0f,0.0f);
			 glVertex3f(0.0f,0.1f,0.0f);

		glColor3f(0.0f,0.0f,1.0f);
			 glVertex3f(0.0f,0.0f,0.0f);
			 glVertex3f(0.0f,0.0f,10.1f);
	glEnd();
				glColor3f(1.0f,1.0f,1.0f);

  	glEnable(GL_LIGHTING);	
    if (textura_cargada!=0)
    	glEnable(GL_TEXTURE_2D);


		
    if (modo_dibujo==3)
      glBindTexture(GL_TEXTURE_2D, textura);
    for (j = 0; j < model->n_caras; j++) {
        view_x1 = model->triangulos[j].vertices[0].x;
        view_y1 = model->triangulos[j].vertices[0].y;
        view_z1 = model->triangulos[j].vertices[0].z;

        view_x2 = model->triangulos[j].vertices[1].x;
        view_y2 = model->triangulos[j].vertices[1].y;
        view_z2 = model->triangulos[j].vertices[1].z;

        view_x3 = model->triangulos[j].vertices[2].x;
        view_y3 = model->triangulos[j].vertices[2].y;
        view_z3 = model->triangulos[j].vertices[2].z;


        if (modo_dibujo==0) {
          glLineWidth(6);
          glBegin(GL_TRIANGLES);
        }
        else if (modo_dibujo==1){
          glLineWidth(1);
          glBegin(GL_LINES);
        }
        else if (modo_dibujo==3) {
          glLineWidth(6);
          glBegin(GL_TRIANGLES);
        }

        if (modo_dibujo==3)
            glTexCoord2f(model->triangulos[j].vertices[0].u,
                     model->triangulos[j].vertices[0].v);

        glNormal3f(model->triangulos[j].vertices[0].Nx,
                   model->triangulos[j].vertices[0].Ny,
                   model->triangulos[j].vertices[0].Nz);

        glVertex3f(view_x1, view_y1, view_z1);


        if (modo_dibujo==3)
          glTexCoord2f(model->triangulos[j].vertices[1].u,
                     model->triangulos[j].vertices[1].v);

        glNormal3f(model->triangulos[j].vertices[1].Nx,
                   model->triangulos[j].vertices[1].Ny,
                   model->triangulos[j].vertices[1].Nz);
        glVertex3f(view_x2, view_y2, view_z2);

        if (modo_dibujo==3)
          glTexCoord2f(model->triangulos[j].vertices[2].u,
                     model->triangulos[j].vertices[2].v);

        glNormal3f(model->triangulos[j].vertices[2].Nx,
                   model->triangulos[j].vertices[2].Ny,
                   model->triangulos[j].vertices[2].Nz);
        glVertex3f(view_x3, view_y3, view_z3);

        glEnd();
    }


}

void
myReshape(int w, int h)
{
  ww=w;hh=h;
  glViewport(0, 0, w, h);
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();
  gluPerspective(45.0f,(GLfloat) w/h, 0.01f, 100.0f);
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

}

void
myinit(void)
{

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(45.0f,(GLfloat) 1.3, 0.01f, 100.0f);
    glGetDoublev(GL_PROJECTION_MATRIX, &matriz_proyeccion_A[0][0]);
    glLoadMatrixd(&matriz_proyeccion_A[0][0]);

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    glTranslatef(0.0f,0.0f,zoom);
    glGetDoublev(GL_MODELVIEW_MATRIX, &matriz_modelview[0][0]);






    /* Ahora establecemos el color de fondo por defecto. Está en formato RGBA y lo ponemos a negro */

    glClearColor(0.0f, 0.0f, 0.0f, 0.0f);

    /* Estas 3 líneas habilitan del Buffer de profundidad */

    glClearDepth(1.0f);

    glEnable(GL_DEPTH_TEST);
    glDepthFunc(GL_LEQUAL);

    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
  	glEnable(GL_ALPHA_TEST);

    /* Esta función sirve para optimizar el renderizado, y se utiliza para muchas cosas. En este caso es para
       hacer un buen cálculo de la perspectiva perdiendo un poco de rendimiento */

    glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);

    /* Cargamos la textura */

    /*glEnable(GL_TEXTURE_2D);
    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
    glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);*/

    glShadeModel(GL_SMOOTH);    /* SMOOTH SHADING */

    glCullFace(GL_BACK);
    glDisable(GL_CULL_FACE);
    glLineWidth(6);

    glLightfv(GL_LIGHT1, GL_AMBIENT, LightAmbient);	
    glLightfv(GL_LIGHT1, GL_DIFFUSE, LightDiffuse1);	
    //glLightfv(GL_LIGHT1, GL_POSITION, LightPosition1);	

  	glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT1);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    display();

}


//===================>>> gearOGLCanvasPane::gearOGLCanvasPane <<<====================
  gearOGLCanvasPane::gearOGLCanvasPane()
  {
    myinit();
    initDone = 0;
  }

//===================>>> gearOGLCanvasPane::~gearOGLCanvasPane <<<====================
  gearOGLCanvasPane::~gearOGLCanvasPane()
  {
  }

//======================>>> gearOGLCanvasPane::TimerAnimate <<<========================
  void gearOGLCanvasPane::TimerAnimate(void)
  {
    // **** Called by CmdWindow AuxTimer for animation.
    vglMakeCurrent();  // Typically done here
    display();
    vglFlush();  // After you draw, typically flush

  }
//======================>>> gearOGLCanvasPane::graphicsInit <<<========================
  void gearOGLCanvasPane::graphicsInit(void)
  {
    vBaseGLCanvasPane::graphicsInit();	// Always call the superclass first!

    // **** Your OpenGL initialization code goes here!

    myinit();
    initDone = 1;
  }
//======================>>> gearOGLCanvasPane::HPage <<<========================
  void gearOGLCanvasPane::HPage(int shown, int top)
  {
    vBaseGLCanvasPane::HPage(shown, top);
  }

//======================>>> gearOGLCanvasPane::VPage <<<========================
  void gearOGLCanvasPane::VPage(int shown, int top)
  {
    vBaseGLCanvasPane::VPage(shown, top);
  }

//=======================>>> gearOGLCanvasPane::HScroll <<<======================
  void gearOGLCanvasPane::HScroll(int step)
  {
    vBaseGLCanvasPane::HScroll(step);
  }

//======================>>> gearOGLCanvasPane::VScroll <<<======================
  void gearOGLCanvasPane::VScroll(int step)
  {
    vBaseGLCanvasPane::VScroll(step);
  }

//======================>>> gearOGLCanvasPane::MouseDown <<<======================
  void gearOGLCanvasPane::MouseDown(int X, int Y, int button)
  {

    vBaseGLCanvasPane::MouseUp(X,Y,button);
    raton_pulsado=1;
    rX=X;
    rY=Y;
    //printf("Click!\n");


  }

//========================>>> gearOGLCanvasPane::MouseUp <<<======================
  void gearOGLCanvasPane::MouseUp(int X, int Y, int button)
  {
     vBaseGLCanvasPane::MouseDown(X,Y,button);
     raton_pulsado=0;
     //printf("Clock!!\n");


  }

//======================>>> gearCanvasPane::MouseMove <<<======================
  void gearOGLCanvasPane::MouseMove(int x, int y, int button)
  {

    float spin_quat[4];

    vBaseGLCanvasPane::MouseMove(x,y,button);
    if (button==1){
          glMatrixMode(GL_MODELVIEW);
          glLoadMatrixd(&matriz_modelview[0][0]);
          glRotatef(x-rX,matriz_modelview[0][1],matriz_modelview[1][1],matriz_modelview[2][1]);
          glGetDoublev(GL_MODELVIEW_MATRIX, &matriz_modelview[0][0]);
          glLoadMatrixd(&matriz_modelview[0][0]);
          glRotatef(y-rY,matriz_modelview[0][0],matriz_modelview[1][0],matriz_modelview[2][0]);
          glGetDoublev(GL_MODELVIEW_MATRIX, &matriz_modelview[0][0]);

          rX=x;rY=y;
    }
    if (button==3){
        if (y>rY)
          zoom+=0.02f;
        else
          zoom-=0.02f;
      rX=x;rY=y;
    matriz_modelview[3][2]=(double)zoom;
    }


  }

//=========================>>> gearOGLCanvasPane::Redraw <<<======================
  void gearOGLCanvasPane::Redraw(int x, int y, int w, int h)
  {
    static int inRedraw = 0;

    if (inRedraw || !initDone)  // Don't draw until initialized
        return;

    inRedraw = 1;  // Don't allow recursive redraws.

    vglMakeCurrent();  // Typically done here

    // *** Your drawing code typically goes here. You may
    // insert it here, or just call a drawing routine.

    display();

    vglFlush();  // After you draw, typically flush

    inRedraw = 0;  // Out of Redraw

  }

//======================>>> gearOGLCanvasPane::Resize <<<======================
  void gearOGLCanvasPane::Resize(int w, int h)
  {
    vBaseGLCanvasPane::Resize(w,h);
    myReshape(w,h);
    vglFlush();
  }

